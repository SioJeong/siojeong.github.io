---
id: 19
title: 함수와 함수 호이스팅 그리고 변수 호이스팅과의 차이점
date: 2024-12-19
tag: [JavaScript]
description: '자바스크립트 함수의 정의 방법과 호이스팅의 개념, 그리고 변수 호이스팅과의 차이점을 알아봅니다'
---

![function](/markdowns/images/post11-20/hoisting.png)

## Intro

**스코프, 실행 컨텍스트, 클로저, this, 프로토타입** 등 자바스크립트의 핵심 개념들은 모두 함수와 깊은 관련이 있다.

따라서 함수는 자바스크립트를 정확히 이해하고 사용하기 위해 피해갈 수 없는 핵심 중의 핵심이다.

## 1. 함수를 사용하는 이유

함수는 필요할 때 여러 번 호출할 수 있다. 즉, 실행 시점을 개발자가 결정할 수 있고 몇 번이든 재사용이 가능하다. 동일한 작업을 반복적으로 수행해야 한다면 같은 코드를 중복해서 여러 번 작성하는 것이 아니라 미리 정의된 함수를 재사용하는 것이 효율적이다. 따라서 함수는 **코드의 재사용**이라는 측면에서 매우 유용하다.

함수를 사용하지 않고 같은 코드를 중복해서 여러 번 작성하면 중복된 횟수만큼 코드를 수정해야 한다. 또한 사람은 실수하기 마련이므로 실수할 가능성도 높아진다. 코드의 중복을 억제하고 재사용성을 높이는 함수는 **유지보수의 편의성**을 높이고 실수를 줄여 **코드의 신뢰성**을 높이는 효과가 있다.

예를 들어, 두 수를 더하는 간단한 작업을 함수로 만들어보면

```javascript
// 함수를 사용하지 않은 경우
const result1 = 10 + 20;
const result2 = 30 + 40;
const result3 = 50 + 60;

// 함수를 사용한 경우
function add(a, b) {
    return a + b;
}

const result1 = add(10, 20);
const result2 = add(30, 40);
const result3 = add(50, 60);
```

이처럼 함수를 사용하면 코드의 중복을 줄이고, 나중에 로직을 수정해야 할 때도 함수 내부만 수정할 수 있기에 유지보수가 쉬워진다.

## 2. 함수 정의

함수를 정의하는 방식은 4가지다.

-   함수 선언문
-   함수 표현식
-   Function 생성자 함수
-   화살표 함수(ES6)

### 2.1 함수 선언문

가장 기본적인 함수 정의 방식이다. 함수 선언문은 함수 이름을 생략할 수 없다.

```javascript
function add(x, y) {
    return x + y;
}
```

### 2.2 함수 표현식

자바스크립트에서 함수는 **객체** 타입의 값이다. 따라서 함수는 값처럼 변수에 할당할 수 있다. 함수 표현식의 함수는 함수 이름을 생략할 수 있다. 이를 **익명 함수(Anonymous Function)** 라 한다.

```javascript
const add = function (x, y) {
    return x + y;
};
```

[이전 글](/post/18#:~:text=%3B%20//%20200-,8.%20let%EA%B3%BC%20const,-let%EA%B3%BC%20const)에서 배운 바와 같이, `let`이나 `const`로 함수를 정의하면 변수 호이스팅 특성과 함께 **TDZ**가 적용되어, 선언 전에 함수를 호출하면 `ReferenceError`가 발생할 수 있다는 점에 유의하자.

### 2.3 Function 생성자 함수

Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지도 않다. Function 생성자 함수로 생성한 함수는 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.

주요한 차이점은 다음과 같다

-   클로저를 생성하지 않음
-   자신이 정의된 환경(렉시컬 스코프)을 포획하지 못하고, 항상 전역 스코프를 참조
-   매개변수와 함수 본문을 문자열로 전달해야 함 (보안 이슈)

```javascript
const add = new Function('x', 'y', 'return x + y');

// 클로저가 동작하지 않는 예시
const scope = 'global';
function createFunction() {
    const scope = 'local';
    return new Function('return scope'); // 항상 'global'을 참조
}
```

### 2.4 화살표 함수

ES6에서 도입된 화살표 함수는 `function` 키워드 대신 화살표(`=>`)를 사용해 더욱 간략한 방법으로 함수를 선언할 수 있다. 화살표 함수는 항상 익명 함수로 정의한다.

또한 자신만의 **this, arguments, super, new.target을 갖지 않는다는 특징**이 있다. 이는 화살표 함수가 자신을 포함하는 외부 스코프의 this를 그대로 사용한다는 것을 의미하며, 함수 스코프 내에서 기존 함수를 사용하듯이 this를 바인딩하고 싶다면, 화살표 함수의 특징을 고려해야 한다.

```javascript
const add = (x, y) => x + y;

// this 바인딩 예시
const obj = {
    value: 1,
    normal: function () {
        console.log(this.value); // 1
    },
    arrow: () => {
        console.log(this.value); // undefined
    },
};
```

## 3. 함수 호이스팅

### 3.1 함수 선언문의 호이스팅

함수 선언문으로 정의한 함수는 **함수 호이스팅**에 의해 함수 선언문 이전에 호출할 수 있다. 자바스크립트 엔진은 런타임에 코드 한 줄 한 줄을 실행하기 전에, 모든 선언문(변수 선언문, 함수 선언문 등)을 먼저 처리하기 때문이다.

```javascript
// 함수 호출
console.log(add(2, 5)); // 7

// 함수 선언문
function add(x, y) {
    return x + y;
}
```

위 예시처럼 함수가 선언되기 전에 호출해도 에러가 나지 않는 것은, 자바스크립트 엔진이 함수 선언문을 만나면 런타임 이전에 함수 객체를 생성하고 식별자(add)에 미리 할당해 두기 때문이다.

### 3.2 함수 표현식에는 함수 호이스팅이 발생하지 않는다

반면, 함수 표현식은 아래와 같이 코드가 실행되는 시점(런타임)에 평가되어 함수 객체로 생성된다. 따라서 함수 표현식 이전에 함수를 호출하면 에러가 발생한다.

```javascript
// 함수 호출
console.log(add(2, 5)); // ReferenceError: add is not defined

// 함수 표현식
const add = function (x, y) {
    return x + y;
};
```

이 경우는 함수 호이스팅이 아니라, 이전 글에서 배웠던 변수 호이스팅이 일어난다. 즉, add라는 변수 자체는 선언되지만(호이스팅), **초기화되지 않은 상태(TDZ)** 에 있기 때문에 함수를 참조하기 전에 호출하면 에러가 발생한다.

## 4. 변수 호이스팅과의 차이점

### 4.1 `var` vs. 함수 선언문

`var` 키워드를 사용한 변수 선언문, 그리고 함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점에서 동일하다. 하지만

-   `var score;` 는 자바스크립트 엔진이 런타임 이전에 `score` 식별자를 등록하고, 초기값을 `undefined`로 설정한다
-   `function foo() { ... }` 는 엔진이 런타임 이전에 함수 객체를 미리 생성하고, `foo` 식별자에 할당한다.

따라서 `var` 키워드를 사용한 변수 선언문 이전에 변수를 참조하면 `undefined`로 평가되지만, 함수 선언문으로 정의한 함수를 선언문 전에 호출하면 정상적으로 동작한다.

코드로 예시를 보면

```javascript
console.log(num); // undefined
var num = 10;

console.log(foo()); // 정상적으로 함수 실행
function foo() {
    return 'Hello';
}

console.log(bar()); // TypeError: bar is not a function
var bar = function () {
    return 'Hi';
};
```

### 4.2 `let` / `const`는 TDZ로 인해 함수 이전 호출이 불가능하다

이전 글에서 자세히 다루었듯이, `let`과 `const`로 선언된 변수도 호이스팅은 발생하지만, **TDZ(Temporal Dead Zone)** 덕분에 선언 전에 참조할 수 없다. 함수 표현식을 `let`, `const`로 선언한다면, 선언문 전에 함수를 호출할 경우 `ReferenceError`가 발생한다.

## 5. 함수 표현식을 권장하는 이유

함수 선언문은 **호출보다 선언이 아래 있어도 무조건 동작한다**는 점에서 편리할 수 있지만, 코드 흐름 상 의도치 않게 전역 공간을 오염시킬 가능성이 있고, 가독성이 저하될 수 있다.

반면에, 함수 표현식은 변수에 할당되는 시점에 함수가 생성되므로, 가독성과 유지보수 측면에서 명시적이고 안전하다.

또한 ES6 이후에는 `let`, `const`가 추가되면서 TDZ 덕분에 선언 전 호출을 방지할 수 있으므로, 의도치 않은 버그를 줄일 수 있다. “의도는 명확하게, 동작 시점은 예측 가능하게”라는 클린 코드 원칙에도 부합하기에, 최근에는 함수 선언문 대신 함수 표현식을 사용하거나 화살표 함수를 선호하는 추세다.

## Reference

-   [함수](https://poiemaweb.com/js-function)
-   [호이스팅](https://developer.mozilla.org/ko/docs/Glossary/Hoisting)
